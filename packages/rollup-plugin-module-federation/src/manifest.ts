import {
  DEFAULT_PKG_NAME,
  MODULE_VERSION_UNSPECIFIED,
  REMOTE_ENTRY_NAME,
} from './constants';
import type { moduleFederationPlugin, Manifest, ManifestShared } from '@module-federation/sdk';
import type { PackageJson } from 'type-fest';
import type { ExposesObject, RemotesObject } from './types';
import type { OutputBundle } from 'rollup';
import type { UserOptions, ShareArgs } from '@module-federation/runtime/types';

export function getSharedManifest(instanceName: string, sharedPkgName: string, sharedPkgConfig: ShareArgs): ManifestShared {
  return {
    id: `${instanceName}:${sharedPkgName}`,
    name: sharedPkgName,
    version: sharedPkgConfig?.version
      ? sharedPkgConfig?.version
      : MODULE_VERSION_UNSPECIFIED,
    singleton: sharedPkgConfig.shareConfig?.singleton ?? false,
    requiredVersion: sharedPkgConfig.shareConfig?.requiredVersion
      ? sharedPkgConfig.shareConfig.requiredVersion
      : MODULE_VERSION_UNSPECIFIED,
    hash: '', // Doesn't seem to be generated by rspack. Need to check.
    assets: {
      js: {
        async: [],
        sync: [],
      },
      css: {
        async: [],
        sync: [],
      },
    },
  };
}

/**
 * Implements the manifest generation logic according to the spec: https://github.com/module-federation/core/issues/2496
 * @param federationConfig
 * @returns
 */
export function generateManifest(
  pkgJson: PackageJson,
  federationConfig: moduleFederationPlugin.ModuleFederationPluginOptions,
  exposes: ExposesObject,
  remotes: RemotesObject,
  initConfig: UserOptions,
  bundle: OutputBundle,
): Manifest {
  const instanceName =
    federationConfig.name ?? pkgJson.name ?? DEFAULT_PKG_NAME;
  return {
    id: instanceName,
    name: instanceName,
    metaData: {
      name: instanceName,
      type: 'app',
      buildInfo: {
        buildVersion: pkgJson.version ?? MODULE_VERSION_UNSPECIFIED,
        buildName: pkgJson.name ?? DEFAULT_PKG_NAME, // TODO: Need to sanitize this
      },
      remoteEntry: {
        name: federationConfig?.filename || `${REMOTE_ENTRY_NAME}.js`,
        path: '',
        type: federationConfig?.library?.type === 'module' ? 'esm' : 'global',
      },
      types: {
        path: '',
        name: '',
        zip: '',
        api: '',
      },
      globalName: instanceName,
      pluginVersion: '',
      publicPath: '',
    },
    shared: Object.entries(initConfig.shared ?? {}).reduce<ManifestShared[]>((sharedManifest, [sharedPkgName, sharedPkgConfig]) => {
      if (Array.isArray(sharedPkgConfig)) {
        return sharedManifest.concat(
          sharedPkgConfig.map((config) =>
            getSharedManifest(instanceName, sharedPkgName, config),
          ),
        );
      } else {
        sharedManifest.push(
          getSharedManifest(instanceName, sharedPkgName, sharedPkgConfig)
        );
      } 
      return sharedManifest;
    }, []),
    exposes: Object.entries(exposes).map(([key, value]) => ({
      id: '',
      name: '',
      assets: {
        js: {
          async: [],
          sync: [],
        },
        css: {
          async: [],
          sync: [],
        },
      },
      path: '',
    })),
    remotes: Object.entries(remotes).map(([key, value]) => ({
      federationContainerName: '',
      moduleName: '',
      alias: '',
      entry: '',
    })),
  };
}
